// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/ogreks/meeseeks-box/internal/model"
)

func newUserSignature(db *gorm.DB, opts ...gen.DOOption) userSignature {
	_userSignature := userSignature{}

	_userSignature.userSignatureDo.UseDB(db, opts...)
	_userSignature.userSignatureDo.UseModel(&model.UserSignature{})

	tableName := _userSignature.userSignatureDo.TableName()
	_userSignature.ALL = field.NewAsterisk(tableName)
	_userSignature.ID = field.NewInt64(tableName, "id")
	_userSignature.Type = field.NewInt32(tableName, "type")
	_userSignature.UserID = field.NewInt64(tableName, "user_id")
	_userSignature.AccountID = field.NewInt64(tableName, "account_id")
	_userSignature.AccountAid = field.NewString(tableName, "account_aid")
	_userSignature.AgreementID = field.NewInt64(tableName, "agreement_id")
	_userSignature.AgreementNo = field.NewString(tableName, "agreement_no")
	_userSignature.Signed = field.NewBool(tableName, "signed")
	_userSignature.SignedAt = field.NewTime(tableName, "signed_at")
	_userSignature.CreatedAt = field.NewTime(tableName, "created_at")
	_userSignature.UpdatedAt = field.NewTime(tableName, "updated_at")
	_userSignature.DeletedAt = field.NewTime(tableName, "deleted_at")

	_userSignature.fillFieldMap()

	return _userSignature
}

// userSignature 用户签署表
type userSignature struct {
	userSignatureDo

	ALL         field.Asterisk
	ID          field.Int64
	Type        field.Int32  // 签署类型
	UserID      field.Int64  // 用户id
	AccountID   field.Int64  // 账号id
	AccountAid  field.String // 账号aid
	AgreementID field.Int64  // 协议id
	AgreementNo field.String // 协议编号
	Signed      field.Bool   // 是否已签署 0 否 1是
	SignedAt    field.Time   // 签署时间
	CreatedAt   field.Time   // 创建时间
	UpdatedAt   field.Time   // 更新时间
	DeletedAt   field.Time

	fieldMap map[string]field.Expr
}

func (u userSignature) Table(newTableName string) *userSignature {
	u.userSignatureDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userSignature) As(alias string) *userSignature {
	u.userSignatureDo.DO = *(u.userSignatureDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userSignature) updateTableName(table string) *userSignature {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt64(table, "id")
	u.Type = field.NewInt32(table, "type")
	u.UserID = field.NewInt64(table, "user_id")
	u.AccountID = field.NewInt64(table, "account_id")
	u.AccountAid = field.NewString(table, "account_aid")
	u.AgreementID = field.NewInt64(table, "agreement_id")
	u.AgreementNo = field.NewString(table, "agreement_no")
	u.Signed = field.NewBool(table, "signed")
	u.SignedAt = field.NewTime(table, "signed_at")
	u.CreatedAt = field.NewTime(table, "created_at")
	u.UpdatedAt = field.NewTime(table, "updated_at")
	u.DeletedAt = field.NewTime(table, "deleted_at")

	u.fillFieldMap()

	return u
}

func (u *userSignature) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userSignature) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 12)
	u.fieldMap["id"] = u.ID
	u.fieldMap["type"] = u.Type
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["account_id"] = u.AccountID
	u.fieldMap["account_aid"] = u.AccountAid
	u.fieldMap["agreement_id"] = u.AgreementID
	u.fieldMap["agreement_no"] = u.AgreementNo
	u.fieldMap["signed"] = u.Signed
	u.fieldMap["signed_at"] = u.SignedAt
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["deleted_at"] = u.DeletedAt
}

func (u userSignature) clone(db *gorm.DB) userSignature {
	u.userSignatureDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u userSignature) replaceDB(db *gorm.DB) userSignature {
	u.userSignatureDo.ReplaceDB(db)
	return u
}

type userSignatureDo struct{ gen.DO }

type IUserSignatureDo interface {
	gen.SubQuery
	Debug() IUserSignatureDo
	WithContext(ctx context.Context) IUserSignatureDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserSignatureDo
	WriteDB() IUserSignatureDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserSignatureDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserSignatureDo
	Not(conds ...gen.Condition) IUserSignatureDo
	Or(conds ...gen.Condition) IUserSignatureDo
	Select(conds ...field.Expr) IUserSignatureDo
	Where(conds ...gen.Condition) IUserSignatureDo
	Order(conds ...field.Expr) IUserSignatureDo
	Distinct(cols ...field.Expr) IUserSignatureDo
	Omit(cols ...field.Expr) IUserSignatureDo
	Join(table schema.Tabler, on ...field.Expr) IUserSignatureDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserSignatureDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserSignatureDo
	Group(cols ...field.Expr) IUserSignatureDo
	Having(conds ...gen.Condition) IUserSignatureDo
	Limit(limit int) IUserSignatureDo
	Offset(offset int) IUserSignatureDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserSignatureDo
	Unscoped() IUserSignatureDo
	Create(values ...*model.UserSignature) error
	CreateInBatches(values []*model.UserSignature, batchSize int) error
	Save(values ...*model.UserSignature) error
	First() (*model.UserSignature, error)
	Take() (*model.UserSignature, error)
	Last() (*model.UserSignature, error)
	Find() ([]*model.UserSignature, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserSignature, err error)
	FindInBatches(result *[]*model.UserSignature, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UserSignature) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserSignatureDo
	Assign(attrs ...field.AssignExpr) IUserSignatureDo
	Joins(fields ...field.RelationField) IUserSignatureDo
	Preload(fields ...field.RelationField) IUserSignatureDo
	FirstOrInit() (*model.UserSignature, error)
	FirstOrCreate() (*model.UserSignature, error)
	FindByPage(offset int, limit int) (result []*model.UserSignature, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserSignatureDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userSignatureDo) Debug() IUserSignatureDo {
	return u.withDO(u.DO.Debug())
}

func (u userSignatureDo) WithContext(ctx context.Context) IUserSignatureDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userSignatureDo) ReadDB() IUserSignatureDo {
	return u.Clauses(dbresolver.Read)
}

func (u userSignatureDo) WriteDB() IUserSignatureDo {
	return u.Clauses(dbresolver.Write)
}

func (u userSignatureDo) Session(config *gorm.Session) IUserSignatureDo {
	return u.withDO(u.DO.Session(config))
}

func (u userSignatureDo) Clauses(conds ...clause.Expression) IUserSignatureDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userSignatureDo) Returning(value interface{}, columns ...string) IUserSignatureDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userSignatureDo) Not(conds ...gen.Condition) IUserSignatureDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userSignatureDo) Or(conds ...gen.Condition) IUserSignatureDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userSignatureDo) Select(conds ...field.Expr) IUserSignatureDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userSignatureDo) Where(conds ...gen.Condition) IUserSignatureDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userSignatureDo) Order(conds ...field.Expr) IUserSignatureDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userSignatureDo) Distinct(cols ...field.Expr) IUserSignatureDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userSignatureDo) Omit(cols ...field.Expr) IUserSignatureDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userSignatureDo) Join(table schema.Tabler, on ...field.Expr) IUserSignatureDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userSignatureDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserSignatureDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userSignatureDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserSignatureDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userSignatureDo) Group(cols ...field.Expr) IUserSignatureDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userSignatureDo) Having(conds ...gen.Condition) IUserSignatureDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userSignatureDo) Limit(limit int) IUserSignatureDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userSignatureDo) Offset(offset int) IUserSignatureDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userSignatureDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserSignatureDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userSignatureDo) Unscoped() IUserSignatureDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userSignatureDo) Create(values ...*model.UserSignature) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userSignatureDo) CreateInBatches(values []*model.UserSignature, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userSignatureDo) Save(values ...*model.UserSignature) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userSignatureDo) First() (*model.UserSignature, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserSignature), nil
	}
}

func (u userSignatureDo) Take() (*model.UserSignature, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserSignature), nil
	}
}

func (u userSignatureDo) Last() (*model.UserSignature, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserSignature), nil
	}
}

func (u userSignatureDo) Find() ([]*model.UserSignature, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserSignature), err
}

func (u userSignatureDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserSignature, err error) {
	buf := make([]*model.UserSignature, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userSignatureDo) FindInBatches(result *[]*model.UserSignature, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userSignatureDo) Attrs(attrs ...field.AssignExpr) IUserSignatureDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userSignatureDo) Assign(attrs ...field.AssignExpr) IUserSignatureDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userSignatureDo) Joins(fields ...field.RelationField) IUserSignatureDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userSignatureDo) Preload(fields ...field.RelationField) IUserSignatureDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userSignatureDo) FirstOrInit() (*model.UserSignature, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserSignature), nil
	}
}

func (u userSignatureDo) FirstOrCreate() (*model.UserSignature, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserSignature), nil
	}
}

func (u userSignatureDo) FindByPage(offset int, limit int) (result []*model.UserSignature, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userSignatureDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userSignatureDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userSignatureDo) Delete(models ...*model.UserSignature) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userSignatureDo) withDO(do gen.Dao) *userSignatureDo {
	u.DO = *do.(*gen.DO)
	return u
}
